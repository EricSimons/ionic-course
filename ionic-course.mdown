# Introduction
Web development technologies have evolved at an incredible clip over the past few years. We've gone from rudimentary DOM manipulation with libraries like jQuery to supercharged web applications organized & powered by elegant MV* based frameworks like AngularJS. Pair this with significant increases in browser rendering speeds, and it is now easier than ever before to build production quality applications on top of Javascript, HTML5 and CSS3.

While these advances have been incredible, they are only just starting to affect the clear platform of the future: mobile. For years, mobile rendering speeds were atrocious and the MVC frameworks & UI libraries provided by iOS and Android were far superior to writing mobile apps using web technologies. There were also some very public failures -- Facebook famously wrote their first iOS app in 2011 using HTML5, but ended up scrapping it due to terrible performance. (mention react native here perhaps)

For years now, hybrid apps have been mocked and jeered by native app developers for being clunky and ugly, subpar performance, and having no advantages over native apps. While these may have been valid reasons in 2011, they are now virtually baseless thanks to a collection of new technologies that have emerged over the past two years. With these technologies, you can design, build and deploy robust mobile apps faster than you could with native technologies while incurring little to no app performance penalties, with thanks in large part to super fast mobile browser rendering speeds. This course is designed to teach you how to effectively use these new technologies to build insanely great mobile apps.

Without further ado, we'd like to welcome you to the future of mobile app development freed from the shackles of native languages & frameworks. Lets learn what the new mobile stack consists of and how it works.

## The new technologies powering modern hybrid apps
Before, building hybrid apps was a chore -- not because it was hard to build web pages, but because it was hard to build fully fledged web applications. With AngularJS that has now changed, and as a result, Angular became the core innovation that made hybrid apps possible. The bright folks at Drifty were some of the first to realize this and subsequently created the Ionic Framework to bridge the gap between AngularJS web apps and hybrid mobile apps. Since launching a little over a year ago, the Ionic Framework has [quickly grown in popularity amongst developers](http://www.google.com/trends/explore?hl=en-US&q=ionic+framework&cmpt=q&tz&tz&content=1) and their [main Github repo](https://github.com/driftyco/ionic) has over 13K stars as of this writing.

[where-ionic-fits] For a more in depth view of where Ionic fits into our hybrid app stack, [read this blog post](http://ionicframework.com/blog/where-does-the-ionic-framework-fit-in/) from one of Ionic's core developers and [read the "Overview" section](http://ionicframework.com/docs/overview/) on their about page.

[ Maybe mention that if were building mobile web ionic is enough, but if we want an app, we have to package ]

With our frontend technologies taken care of, we'll now need a way to package our app and run it on mobile devices. For this, Cordova is a fantastic solution. For those unfamiliar with Cordova, Adobe describes it via analogy: Cordova is to PhoneGap as Blink is to Chrome. Basically, PhoneGap is Cordova plus a whole bunch of other Adobe stuff.

[cordova-vs-phonegap] [Read this post for a more in depth understanding of the differences between Cordova and PhoneGap](http://ionicframework.com/blog/what-is-cordova-phonegap/)

The folks at Ionic have done a fantastic job of making Cordova super easy to use by directly wrapping it in their 'ionic' command line tool (don't worry, we'll cover this later). Just remember that Cordova is something that is running under the hood of your app that you will rarely need to worry about, but we will cover some common interactions with it in this course.

## What we're going to build
We will be building an app called Songhop -- a "Tinder for music" app that allows you to listen to 30 second song samples and favorite the ones you like. This is based on a real Ionic/Cordova powered app we built that exists on the iOS App Store -- feel free to download it to get a feeling for what you're about to build (and rate it 5 stars :). It's also worth noting that it only took us a month to build the Songhop app that's on the App Store, so that should give you an idea of how fast you can build & iterate using Ionic / Cordova.

We'll be covering a wide variety of topics in this course: scaffolding a new application, testing it in the emulator, installing native plugins for manipulating audio & more, swipe gestures for our interface, installing the app on your own device, deploying to the iOS & Android app stores, and so much more.

[ Talk about course structure here -- first X chapters are on ionic, remaining 3 chapters cover building & deploying to phones/app stores etc ]


## Prerequisites

[javascript-prereq] __Basic programming / JavaScript knowledge.__ If you don't know JavaScript, this guide is a good place to start.

[angular-prereq] __Familiarity with AngularJS.__ We will be using AngularJS for much of our app logic. If you aren't familiar with AngularJS, we highly recommend going through the course "A Better Way to Learn AngularJS".

In addition, you should be comfortable with basic web application concepts including REST and CRUD.

It's best to have either a Linux based OS or Mac to complete this tutorial. While it's certainly possible to develop on Windows, we won't be covering the specifics of running, debugging and troubleshooting Cordova on Windows. If you need to use Windows, we recommend reading this article which will help.

// Maybe look into phonegap build as an option here?

[install-node]  __Install Node.js__. Since you will need to install various packages for Node.js, we recommend that you follow these installation instructions which use npm.

[install-ionic-cli]  __Install the [Ionic CLI](http://ionicframework.com/docs/cli/install.html)__ through npm by running `npm install -g ionic`. We'll be using it to develop and test our app in a web browser, and later for packaging our app into native binaries for mobile devices.


## Recommendations for completing this course
Throughout this course, links to additional concepts and information will be included. You can use these links as supplementary material which can help you gain insight into the stack and its various components. As always, if you have any questions Google and Stackoverflow are your best bet. If you're unsure about something specific to this tutorial, feel free to drop me a line at eric@thinkster.io

We're firm believers in actually writing code while learning a new language or framework. Therefore, we strongly encourage you to type out all the code instead of copy+pasting it.


# Starting our project
When you want to [start a new Ionic project](http://ionicframework.com/docs/cli/start.html), typically all you need to do is run `ionic start myApp blank' and it will scaffold a new application for you. However, for simplicity's sake, we've created a starter project specifically for this course that includes all the base HTML/CSS/JS files we'll be using.

[fork-app-from-gh] Clone [the ionic-songhop-app repo](https://github.com/EricSimons/ionic-songhop-app) and then run the command `git checkout -f checkpoint-0`. This will reset your workspace to the very beginning of the application. You can also [view the source code](https://github.com/EricSimons/ionic-songhop-app/tree/checkpoint-0) or [download a zip/tarball](https://github.com/EricSimons/ionic-songhop-app/archive/checkpoint-0.zip) on Github.

Now that we have the Songhop project downloaded to our computer, lets get it running in our browser! To do this, we will use the Ionic CLI's command 'serve'. This command starts a local web server with live reload enabled, and then opens your browser directly to your application. As you develop your app, it will automatically refresh your web browser every time you save a file. _You can learn more about how the ionic serve command works & various configuration options available [here](http://ionicframework.com/docs/cli/test.html)._

[run-ionic-serve] In your terminal, head into the ionic-songhop-app folder and run `ionic serve`

If all went well, you should be seeing this in your browser window (be sure to resize your browser to be about the size of a phone, or use your browser's phone emulation tools):
![The boilerplate songhop template](images/0.png)

## The guts of an Ionic application
When you scaffold a new application using the Ionic CLI, it automatically creates a handful of files to be used as the baseboard for your hybrid app development. [This post](/ionic-app-structure) walks through all of these files and what purposes they serve. The www folder is where you'll be spending most of your time, as that's where you will be writing your JavaScript, HTML and CSS for the Songhop app. Lets explore the different files in /www and see how they're connected to each other.

The www/index.html file is where your application starts: it loads the JavaScript & CSS files you write (from www/js and www/css), the JavaScript & CSS files that your application depends on, and sets up HTML elements for your AngularJS app to bind to.

Open up app/index.html in your code editor and look over its structure. Notice that we're attaching our AngularJS application to the body element <body ng-app="songhop"> and all of our views are being rendered in an [ion-nav-view](http://ionicframework.com/docs/api/directive/ionNavView/)  (and notice the [ion-nav-back-button](http://ionicframework.com/docs/api/directive/ionNavBackButton/) too):

```html
  <body ng-app="songhop">
    <!--
      The nav bar that will be updated as we navigate between views.
    -->
    <ion-nav-bar class="bar-stable">
      <ion-nav-back-button>
      </ion-nav-back-button>
    </ion-nav-bar>
    <!--
      The views will be rendered in the <ion-nav-view> directive below
      Templates are in the /templates folder (but you could also
      have templates inline in this html file if you'd like).
    -->
    <ion-nav-view></ion-nav-view>
  </body>
```

As we navigate through our app, Ionic uses the [AngularUI Router](https://github.com/angular-ui/ui-router) to populate ion-nav-view's with necessary templates and controllers. At this point you might be wondering, how do we tell an ion-nav-view which templates to display? If you open up /www/js/app.js, in the config block it defines the states of our application. There are three states currently defined for our app: an [abstract state](https://github.com/angular-ui/ui-router/wiki/Nested-States-%26-Nested-Views#abstract-states) called 'tab' that displays templates/tabs.html, and two tab states ('tab.discover', 'tab.favorites') for our Discover and Favorites pages respectively.

You may have noticed that our tab.discover and tab.favorites states specify views to be displayed in (in this case, tab.discover is asking to be displayed in a view titled 'tab-discover'):

```javascript
...
  .state('tab.discover', {
    url: '/discover',
    views: {
      'tab-discover': {
        templateUrl: 'templates/discover.html',
        controller: 'DiscoverCtrl'
      }
    }
  })
 ..
```

If you open up templates/tabs.html, you'll see that there are two ion-nav-view elements wrapped inside their respective [ion-tab](http://ionicframework.com/docs/api/directive/ionTabs/). This allows us to programmatically display our templates into a specified tab, with the added benefit of each tab having its own navigation history.

Finally, lets take a look at the templates of our Discover and Favorites pages. Our templates/discover.html file contains an Ionic [Card Image](http://ionicframework.com/docs/components/#card-showcase) containing the song information along with favorite/skip buttons, and templates/favorites.html contains an [ion-list](http://ionicframework.com/docs/api/directive/ionList/) of our favorite songs. You'll notice that both pages are wrapped in an [ion-view](http://ionicframework.com/docs/api/directive/ionView/) for navigation and header bar purposes, and then an [ion-content](http://ionicframework.com/docs/api/directive/ionContent/) where we place all of our content.

We've used a couple of Ionic's [CSS Components](http://ionicframework.com/docs/components/) and [AngularJS Extensions](http://ionicframework.com/docs/api/) in this base application, and we strongly recommend checking out other components and extensions that Ionic can do out of the box. Knowing what Ionic can do for you will allow you to build applications quickly, as you can lean on Ionic's pre-built components & extensions instead of writing your own hand-rolled solutions.

Now that we've explored our base application structure and how everything is wired together, lets start building out the functionality our application!

# Building interface functionality
Lets start with our main interface, "Discover", where the user will be presented with songs to "favorite" or "skip". In a few chapters we will retrieve these songs from a server, but for now lets add some mock data to the discover controller to prototype with.

[add-mock-data] Add the `$scope.songs` array to your discover controller (feel free to copy and paste)

```javascript
.controller('DiscoverCtrl', function($scope) {
  // our first three songs
  $scope.songs = [
     {
        "title":"Stealing Cinderella",
        "artist":"Chuck Wicks",
        "image_small":"https://i.scdn.co/image/d1f58701179fe768cff26a77a46c56f291343d68",
        "image_large":"https://i.scdn.co/image/9ce5ea93acd3048312978d1eb5f6d297ff93375d"
     },
     {
        "title":"Venom - Original Mix",
        "artist":"Ziggy",
        "image_small":"https://i.scdn.co/image/1a4ba26961c4606c316e10d5d3d20b736e3e7d27",
        "image_large":"https://i.scdn.co/image/91a396948e8fc2cf170c781c93dd08b866812f3a"
     },
     {
        "title":"Do It",
        "artist":"Rootkit",
        "image_small":"https://i.scdn.co/image/398df9a33a6019c0e95e3be05fbaf19be0e91138",
        "image_large":"https://i.scdn.co/image/4e47ee3f6214fabbbed2092a21e62ee2a830058a"
     }
  ];
```

When a user is on the discover page, at any given time there will be a song that's currently playing. Since we'll need to display the song's metadata in the template (song name, artist, etc), lets create a scope variable called currentSong that will hold all of the current song's information.

[create-scope.currentSong] When we first initialize the discover controller, lets set currentSong to the first song in our songs array:
```javascript
  // initialize the current song
  $scope.currentSong = angular.copy($scope.songs[0]);
```
You'll notice that we used [angular.copy](https://docs.angularjs.org/api/ng/function/angular.copy), which makes a deep copy of the object instead of creating a reference to the object in our songs array. If you're unfamiliar with how angular.copy works, you can learn more by [watching this video](https://thinkster.io/egghead/angular-copy).

Now that the current song is being exposed to the scope, we can now wire up our template to the currentSong object.
[show-song-metadata] Update our discover.html template to show the current song:
```html
      <div class="item item-image">
        <img ng-src="{{ currentSong.image_large }}">
      </div>

      <div class="item">
        <h2>{{ currentSong.title }}</h2>
        <p>{{ currentSong.artist }}</p>
      </div>
```

At this point you should be seeing the album art, artist name and title of the first song: "Stealing Cinderella" by Chuck Wicks. If you're feeling unmotivated right now, go listen to this song on Spotify, because it totally sucks and you'll want to hit the skip button out of sheer spite. So for everyone's sanity, lets make that skip button work (as well as the favorite button).

In our discover controller, lets create a scope method called sendFeedback that is fired when the skip and favorite buttons are pressed. This method will accept one argument: a boolean where true = the song was favorited, and false = the song was skipped.

[create-sendfeedback-method] Create the sendFeedback method, which (for now) just changes the currentSong to a random song in our `songs` array. (For those wondering about the unused `bool` argument, don't worry - we'll be using it very soon).
```javascript
  // fired when we favorite / skip a song.
  $scope.sendFeedback = function (bool) {

    // set the current song to one of our three songs
    var randomSong = Math.round(Math.random() * ($scope.songs.length - 1));

    // update current song in scope
    $scope.currentSong = angular.copy($scope.songs[randomSong]);

  }
```


[wireup-feedback-btns] Now wire up the skip & feedback buttons to fire the `sendFeedback` method, with `false` and `true` as the argument respectively:
```html
      <div class="item tabs tabs-secondary tabs-icon-left">
        <a class="tab-item" ng-click="sendFeedback(false)">
          <i class="icon ion-close"></i>
          Skip
        </a>
        <a class="tab-item" ng-click="sendFeedback(true)">
          <i class="icon ion-heart"></i>
          Favorite
        </a>
      </div>
```
And now when you hit skip or favorite, you will proceed to a new song!

Having the song information change is cool, but it would be _super_ cool if the entire card animated left or right if the user skipped or favorited, respectively. We can do this by using [angular animations](https://docs.angularjs.org/guide/animations); open up css/style.css and you can see the ng-hide styles associated with `.discover-page .current-song`. We've also defined separate animations for `.current-song.skipped.ng-hide` and `.current-song.favorited.ng-hide` - this means we will have to add the CSS class 'skipped' or 'favorited' to our current song div, depending if the user skips or favorites.

[sendFeedback-method-animations] First lets update our sendFeedback method to enable animations. currentSong.rated will tell the scope whether the current song was favorited (true) or skipped (false). We will also tell the current card to hide itself with currentSong.hide.

```javascript
  $scope.sendFeedback = function (bool) {

    // set variable for the correct animation sequence
    $scope.currentSong.rated = bool;
    $scope.currentSong.hide = true;

    $timeout(function() {
      // $timeout to allow animation to complete before changing to next song
      // set the current song to one of our three songs
      var randomSong = Math.round(Math.random() * ($scope.songs.length - 1));

      // update current song in scope
      $scope.currentSong = angular.copy($scope.songs[randomSong]);

    }, 250);
  }
```

[inject-timeout-discover] Since we're using $timeout, we'll need to inject it into our discover controller:
```javascript
.controller('DiscoverCtrl', function($scope, $timeout) {
```

[add-ngclass-animation] Now open up discover.html and lets wire these two variables up to our CSS animation classes.

```html
    <div class="list card current-song"
          ng-class="{skipped: currentSong.rated == false,
                     favorited: currentSong.rated == true}"
          ng-show="currentSong && !currentSong.hide">
```

Now our sexy skip and favorite animations should work!

Right now, nothing happens when we favorite a song, but what we want to happen is for it to appear in our favorites tab. To do that, we need to create a service that will add, remove and retrieve the songs we've favorited.

[create-user-svc] Lets create a User [factory](https://docs.angularjs.org/guide/providers) in services.js where we'll store an array of our favorite songs:

```javascript
angular.module('songhop.services', [])
.factory('User', function() {
  
  var o = {
    favorites: []
  }

  return o;
});
```

[add-fav-svc] Now create a method for adding songs to our favorites array:

```javascript
  o.addSongToFavorites = function(song) {
    // make sure there's a song to add
    if (!song) return false;

    // add to favorites array
    o.favorites.unshift(song);
  }
```

[favorites->ctrl] We'll need to be able to display this on our favorites page, so crack open our favorites controller and drag down our list of favorites into scope:
```javascript
.controller('FavoritesCtrl', function($scope, User) {
  // get the list of our favorites from the user service
  $scope.favorites = User.favorites;
})
```

[ngrepeat-favs] Now open up discover.html and have our ion-list repeat through our list of favorites:
```html
      <ion-item ng-repeat="song in favorites" class="item-avatar" ng-click="openSong(song)">
        <img ng-src="{{ song.image_small }}">
        <h2>{{ song.title }}</h2>
        <p>{{ song.artist }}</p>
      </ion-item>
```

Finally, lets add songs to our favorites when the user hits the favorite button.

[discover-inject-user] In our discover controller, inject User as a dependency:
```javascript
.controller('DiscoverCtrl', function($scope, $timeout, User) {
```

[save-fav-in-sendfeedback] And then add the current song to our favorites at the beginning line of our sendFeedback method:
```javascript
    // first, add to favorites if they favorited
    if (bool) User.addSongToFavorites($scope.currentSong);
```

Go ahead and favorite a couple of songs, and then go to the favorites page -- all of our songs now show up!

But what if we want to remove a song from our favorites?

[remove-song-svc] Lets add a method in our User service to do that:
```javascript
  o.removeSongFromFavorites = function(song, index) {
    // make sure there's a song to add
    if (!song) return false;

    // add to favorites array
    o.favorites.splice(index, 1);
  }
```

[remove-song-ctrl] In our favorites controller, expose a method that will fire the removeSongFromFavorites User method:
```javascript
  $scope.removeSong = function(song, index) {
    User.removeSongFromFavorites(song, index);
  }
```
You could just write $scope.removeSong = User.removeSongFromFavorites, but if we ever want to have a success message or any perform other scope related activities when a song is removed, we need to do it this way.

[add-ion-option-btn] Finally, lets add an [ion-option-button](http://ionicframework.com/docs/api/directive/ionOptionButton/) for deleting this song to our [ion-item](http://ionicframework.com/docs/api/directive/ionItem/) ng-repeat:
```html
    <ion-list>
      <ion-item ng-repeat="song in favorites" class="item-avatar" ng-click="openSong(song)">
        <img ng-src="{{ song.image_small }}">
        <h2>{{ song.title }}</h2>
        <p>{{ song.artist }}</p>

        <ion-option-button class="button-assertive"
                       ng-click="removeSong(song, $index)">
          <i class="ion-minus-circled"></i>
        </ion-option-button>
      </ion-item>
    </ion-list>
```

Now you can swipe a song to the right, hit the delete button, and the song will disappear - pretty neat!

Our base interface functionality is complete. In the next section, we'll start wiring our app up to data retrieved from a server.

# Wiring it up to a server
Either use our server, or run your own locally
[need to get this running on heroku]

You'll notice in app.'s that we've defined a constant called "SERVER' that has a url attribute:
```javascript
.constant('SERVER', {
  url: 'http://localhost:3000'
  //url: ''
});
```
You'll want to update the url attribute with either your local server (usually http://localhost:3000) or the hosted version we're providing for you over at [INSERT HEROKU URL].

The first thing we'll wire up is actual song recommendations instead of using the mock data. To do this, lets create a "Recommendations" service that will handle retrieving, storing and manipulating our queue of song recommendations.

[create-rec-svc] In services.js, create a new factory called 'Recommendations' that returns a object containing an array (named `queue`) of our current recommendations. Since this factory will be interacting with our server, be sure to inject `$http` and our `SERVER` constant:

```javascript
.factory('Recommendations', function($http, SERVER) {
  var o = {
    queue: []
  };

  return o;
})
```

Our recommendations queue will be empty until we retrieve songs from our server. The server route we need to hit to retrieve new song recommendations is a GET request to http://SERVER-URL/recommendations. It will return an array of ten random songs, which you can see in action here: [HEROKU URL]/recommendations.

[create-getnextsongs] Create the `getNextSongs` method that returns an [$http](https://docs.angularjs.org/api/ng/service/$http) GET request to /recommendations. The success function will add the new songs to our `queue` array:

```javascript
  o.getNextSongs = function() {
    return $http({
      method: 'GET',
      url: SERVER.url + '/recommendations'
    }).success(function(data){
      // merge data into the queue
      o.queue = o.queue.concat(data);
    });
  }
```

When our app first loads up, we'll want to have a method that's fired to initialize our first set of songs. In our DiscoverCtrl, we can just fire `Recommendations.getNextSongs()`. When it returns successfully, we'll set the current song to be the first one in our queue (aka `Recommendations.queue[0]`). The song at index 0 of `Recommendations.queue` should always be the current song.

[getnextsongs-discoverctrl] Inject Recommendations into DiscoverCtrl, remove $scope.songs and $scope.currentSong, and replace with getNextSongs w/ callback

```javascript
.controller('DiscoverCtrl', function($scope, $timeout, User, Recommendations) {
  // get our first songs
  Recommendations.getNextSongs()
    .then(function(){
      $scope.currentSong = Recommendations.queue[0];
    });
```

Our favorite and skip buttons no longer work, as our sendFeedback method isn't wired up to our Recommendations service. We need to create a method in our Recommendations service that allows us to remove the current song from the queue and proceed to the next one.

[rec-nxtsong] Create a `nextSong` method that pops the first array element off of our `queue`:

```javascript
  o.nextSong = function() {
    // pop the index 0 off
    o.queue.shift();
  }
```

In the `sendFeedback` method, fire `Recommendations.nextSong()` and update `$scope.currentSong` accordingly:

```javascript
    // prepare the next song
    Recommendations.nextSong();

    $timeout(function() {
      // $timeout to allow animation to complete
      $scope.currentSong = Recommendations.queue[0];
    }, 250);
```

Cool, now favoriting and skipping works again. Skip a few songs quickly though and you might notice that the images are taking a long time to load, especially if you're on a slow internet connection (which is often the case on mobile). The way to solve this is by caching the image for the next song in the queue - but what's the best way of doing that in a hybrid app?

When we were building the original Songhop app, we originally planned to download the next image to the device and then provide a link to the local file in cache. This would've required us to use native plugins and would've added a good amount of code to our app. This would also be the only solution to use if you were developing this app in a native language, like Swift/Obj-C or Java. However, we have a killer advantage over native apps: we can lean on the web browser for common tasks, like caching. Just by creating `<img src="hello.jpg" />`, we can place an image in the web browser's cache.

Now imagine if we had an image tag with an [ng-src](https://docs.angularjs.org/api/ng/directive/ngSrc) always pointed at the image url for `Recommendations.queue[1]` (aka the next song in the queue). We can make this image nearly invisible with CSS: 1px tall and 1px wide, with an opacity of 0.01 - yet the browser will still download it and place it in cache. Perfect!

[nextalbumimg-method] In our controller, create a method called `nextAlbumImg` that will return the next album's image:

```javascript
  // used for retrieving the next album image.
  // if there isn't an album image available next, return empty string.
  $scope.nextAlbumImg = function() {
    if (Recommendations.queue.length > 1) {
      return Recommendations.queue[1].image_large;
    }

    return '';
  }
```

[nextimg-tag] Then in our discover.html template, add the img-lookahead div with the image tag inside it:
```html
    <div class="img-lookahead">
      <img ng-src="{{ nextAlbumImg() }}" />
    </div>
```

Even if you skip songs as fast as you can, the images are almost always preloaded into the image tag in our img-lookahead div - with no extra code to download them and keep track of their location in cache. This is a great example of how building hybrid apps can often be easier than building native apps.

[dont-be-afraid] Remember - don't be afraid to use the unique features web browsers provide to your advantage! With great power comes great responsibility, and your responsibility when building hybrid apps is to create code that native app developers would drool over.












Add media playback to svc/ctrl
Pause/play when going between tabs
Show # of new favorites in tab bar

# Creating and persisting user data
Create login/signup splash
Create User service for managing/creating user sessions
Create $localstorage plugin
Retrieve user data from server on boot
Save songs to server

# Cordova: Your bridge to native functionality
Everything you need to know about Cordova.
	- We recommend using native plugins whenever possible for performance/reliability
Switch from html5 audio tag to cordova media/file
	-Install media plugin
	-Install file plugin
Emulating iOS/Android
## Deploying Songhop into production
Get the app running on your own device
Deploying to the iOS app store
Deploying to the Android app store

# Where to go next
Tinder-for-x